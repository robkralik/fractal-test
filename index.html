<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Minimal Mandelbrot Zoom</title>
<style>
  html, body, canvas {
    margin: 0; padding: 0; width: 100%; height: 100%; display: block; background: black;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script id="vertex-shader" type="x-shader/x-vertex">
#version 300 es
layout(location = 0) in vec2 a_position;
out vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0, 1);
}
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
#version 300 es
precision highp float;

in vec2 v_uv;
out vec4 outColor;

uniform vec2 u_resolution;
uniform vec2 u_center;
uniform float u_scale;
uniform int u_maxIter;

void main() {
  float aspect = u_resolution.x / u_resolution.y;
  vec2 uv = (v_uv - 0.5) * vec2(aspect, 1.0);
  vec2 c = u_center + uv * u_scale;

  vec2 z = vec2(0.0);
  int iter = 0;
  for (int i = 0; i < 1000; i++) {
    if (i >= u_maxIter) break;
    if (dot(z,z) > 4.0) break;
    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
    iter = i;
  }

  float color = float(iter) / float(u_maxIter);
  vec3 col = vec3(0.5 + 0.5*cos(6.2831*color + vec3(0, 0.6, 1.0)));
  if (iter == u_maxIter) col = vec3(0.0);

  outColor = vec4(col,1.0);
}
</script>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const gl = canvas.getContext('webgl2');
  if (!gl) {
    alert('WebGL2 is not supported on this browser');
    return;
  }

  function compile(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      throw new Error('Shader compile failed');
    }
    return shader;
  }

  const vertexShader = compile(gl.VERTEX_SHADER, document.getElementById('vertex-shader').textContent);
  const fragmentShader = compile(gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').textContent);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error('Program link failed');
  }
  gl.useProgram(program);

  // Fullscreen quad
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  // Uniform locations
  const u_resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
  const u_centerLoc = gl.getUniformLocation(program, 'u_center');
  const u_scaleLoc = gl.getUniformLocation(program, 'u_scale');
  const u_maxIterLoc = gl.getUniformLocation(program, 'u_maxIter');

  let center = { x: -0.75, y: 0 };
  let scale = 3;
  let zoomSpeed = 0.95;
  let maxIter = 300;

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const width = Math.floor(canvas.clientWidth * dpr);
    const height = Math.floor(canvas.clientHeight * dpr);
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, width, height);
    gl.uniform2f(u_resolutionLoc, width, height);
  }
  window.addEventListener('resize', resize);
  resize();

  function animate() {
    scale *= zoomSpeed;

    maxIter = Math.min(1500, Math.floor(300 - Math.log10(scale)*100));

    gl.uniform2f(u_centerLoc, center.x, center.y);
    gl.uniform1f(u_scaleLoc, scale);
    gl.uniform1i(u_maxIterLoc, maxIter);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

</body>
</html>