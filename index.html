<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Mandelbrot Zoom WebGL2</title>
<style>
  html, body, canvas {
    margin: 0; padding: 0; width: 100%; height: 100%; display: block; background: black;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script id="vs" type="x-shader/x-vertex">
#version 300 es
layout(location=0) in vec2 a_pos;
out vec2 v_uv;
void main() {
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0, 1);
}
</script>

<script id="fs" type="x-shader/x-fragment">
#version 300 es
precision highp float;

in vec2 v_uv;
out vec4 outColor;

uniform vec2 u_resolution;
uniform vec2 u_center;
uniform float u_scale;
uniform int u_maxIter;

void main() {
  float aspect = u_resolution.x / u_resolution.y;
  vec2 uv = (v_uv - 0.5) * vec2(aspect, 1.0);
  vec2 c = u_center + uv * u_scale;

  vec2 z = vec2(0.0);
  int i;
  for(i = 0; i < u_maxIter; i++) {
    if(dot(z,z) > 4.0) break;
    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
  }

  float colorVal = float(i) / float(u_maxIter);
  vec3 color = vec3(0.5 + 0.5*cos(6.2831*colorVal + vec3(0, 0.6, 1.0)));
  if(i == u_maxIter) color = vec3(0.0);

  outColor = vec4(color, 1.0);
}
</script>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const gl = canvas.getContext('webgl2');
  if (!gl) {
    alert('WebGL2 not supported');
    return;
  }

  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      throw new Error('Shader compile error');
    }
    return shader;
  }

  const vertexShader = compileShader(gl.VERTEX_SHADER, document.getElementById('vs').textContent);
  const fragmentShader = compileShader(gl.FRAGMENT_SHADER, document.getElementById('fs').textContent);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    throw new Error('Program link error');
  }
  gl.useProgram(program);

  // Fullscreen quad
  const quadBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1, 1,1
  ]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  // Uniform locations
  const u_resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
  const u_centerLoc = gl.getUniformLocation(program, 'u_center');
  const u_scaleLoc = gl.getUniformLocation(program, 'u_scale');
  const u_maxIterLoc = gl.getUniformLocation(program, 'u_maxIter');

  // Initial state
  let centerX = -0.743643887037158704752191506114774;
  let centerY = 0.131825904205311970493132056385139;
  let scale = 0.005;
  let zoomSpeed = 0.97;
  let maxIter = 300;

  // Resize canvas
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const width = Math.floor(canvas.clientWidth * dpr);
    const height = Math.floor(canvas.clientHeight * dpr);
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, width, height);
    gl.uniform2f(u_resolutionLoc, width, height);
  }
  window.addEventListener('resize', resize);
  resize();

  // Animation loop
  function animate(time=0) {
    // Zoom in
    scale *= zoomSpeed;

    // Slightly drift center to follow an interesting edge
    // Here just a fixed offset, but can be improved
    centerX += 0.000005;
    centerY += 0.000002;

    // Increase iterations as zoom deepens
    maxIter = Math.min(1000, Math.floor(300 - Math.log10(scale)*150));

    // Send uniforms
    gl.uniform2f(u_centerLoc, centerX, centerY);
    gl.uniform1f(u_scaleLoc, scale);
    gl.uniform1i(u_maxIterLoc, maxIter);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

</body>
</html>