<!DOCTYPE html>
<html>
<head>
  <title>GPU Fractal</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: sans-serif;
      color: #fff;
    }
    canvas {
      border: 1px solid #333;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    }
    #info-box {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <canvas id="fractalCanvas"></canvas>
  <div id="info-box">
    <p>Zoom Level: <span id="zoom-level">1x</span></p>
  </div>

  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    uniform vec2 u_resolution;
    uniform vec2 u_center;
    uniform float u_zoom;

    const int maxIterations = 500;

    void main() {
      vec2 z = gl_FragCoord.xy;
      
      // Map pixel coordinates to the complex plane
      vec2 c = u_center + (z - u_resolution / 2.0) / u_resolution.y / u_zoom;
      vec2 z_new = c;

      int n = 0;
      for(int i = 0; i < maxIterations; i++) {
        float x_new = z_new.x * z_new.x - z_new.y * z_new.y + c.x;
        z_new.y = 2.0 * z_new.x * z_new.y + c.y;
        z_new.x = x_new;
        
        if (dot(z_new, z_new) > 4.0) {
          n = i;
          break;
        }
        n = i + 1;
      }

      vec4 color;
      if (n == maxIterations) {
        color = vec4(0.0, 0.0, 0.0, 1.0);
      } else {
        // Simple sinusoidal coloring from our previous successful attempt
        float iteration_ratio = float(n) / float(maxIterations);
        float r = sin(0.3 * iteration_ratio * 255.0 + 0.0) * 0.5 + 0.5;
        float g = sin(0.3 * iteration_ratio * 255.0 + 2.0) * 0.5 + 0.5;
        float b = sin(0.3 * iteration_ratio * 255.0 + 4.0) * 0.5 + 0.5;
        color = vec4(r, g, b, 1.0);
      }
      
      gl_FragColor = color;
    }
  </script>

  <script>
    const canvas = document.getElementById('fractalCanvas');
    const zoomLevelSpan = document.getElementById('zoom-level');
    const gl = canvas.getContext('webgl');

    // Make canvas full-screen
    canvas.width = 800;
    canvas.height = 800;

    if (!gl) {
      alert("WebGL is not supported on your device. Please use a different browser.");
      return;
    }

    // Shader compilation
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShaderSource = document.getElementById('vertex-shader').text;
    const fragmentShaderSource = document.getElementById('fragment-shader').text;

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
      return null;
    }

    gl.useProgram(shaderProgram);

    // Vertex data (a full-screen quad)
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
      -1.0, -1.0,
       1.0, -1.0,
      -1.0,  1.0,
      -1.0,  1.0,
       1.0, -1.0,
       1.0,  1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    // Uniform locations (data passed from JS to shader)
    const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
    const centerUniformLocation = gl.getUniformLocation(shaderProgram, 'u_center');
    const zoomUniformLocation = gl.getUniformLocation(shaderProgram, 'u_zoom');

    gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

    // Fractal parameters
    const center = { x: -0.743643887037151, y: 0.131825904205330 };
    let zoom = 1.0;
    
    function render() {
      // Update uniform values
      gl.uniform2f(centerUniformLocation, center.x, center.y);
      gl.uniform1f(zoomUniformLocation, zoom);

      // Draw the quad
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Update zoom and UI
      zoom *= 1.02;
      zoomLevelSpan.textContent = `${zoom.toFixed(2)}x`;

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

  </script>
</body>
</html>
