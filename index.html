<!DOCTYPE html>
<html>
<head>
  <title>Final WebGL Fractal</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: sans-serif;
      color: #fff;
    }
    canvas {
      border: 1px solid #333;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
      width: 100%;
      max-width: 800px;
      height: auto;
    }
    #info-box {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <canvas id="fractalCanvas"></canvas>
  <div id="info-box">
    <p>Zoom Level: <span id="zoom-level">1x</span></p>
  </div>

  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;

    uniform vec2 u_resolution;
    uniform vec2 u_center;
    uniform float u_zoom;

    const int MAX_ITERATIONS = 100; // Reduced for mobile performance

    void main() {
      vec2 c = (gl_FragCoord.xy - u_resolution * 0.5) / (u_resolution.y * u_zoom) + u_center;
      vec2 z = vec2(0.0, 0.0);
      int i;
      for(i = 0; i < MAX_ITERATIONS; i++) {
        float x = z.x * z.x - z.y * z.y + c.x;
        float y = 2.0 * z.x * z.y + c.y;
        z = vec2(x, y);
        if (dot(z, z) > 4.0) break;
      }

      float t = float(i) / float(MAX_ITERATIONS);
      vec3 color = i == MAX_ITERATIONS ? vec3(0.0) : vec3(t, t * t, 1.0 - t);
      gl_FragColor = vec4(color, 1.0);
    }
  </script>

  <script>
    const canvas = document.getElementById('fractalCanvas');
    const zoomLevelSpan = document.getElementById('zoom-level');
    const gl = canvas.getContext('webgl', { antialias: true });

    // Set canvas size accounting for device pixel ratio
    const dpr = window.devicePixelRatio || 1;
    canvas.width = 800 * dpr;
    canvas.height = 800 * dpr;
    canvas.style.width = '800px';
    canvas.style.height = '800px';

    if (!gl) {
      alert("WebGL is not supported on your device. Please use a different browser.");
      return;
    }

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShaderSource = document.getElementById('vertex-shader').text;
    const fragmentShaderSource = document.getElementById('fragment-shader').text;

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    if (!vertexShader || !fragmentShader) {
      console.error('Failed to create shaders');
      return;
    }

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.error('Program linking error:', gl.getProgramInfoLog(shaderProgram));
      return;
    }

    gl.useProgram(shaderProgram);

    // Set up vertex buffer
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
      -1.0, -1.0,
       1.0, -1.0,
      -1.0,  1.0,
      -1.0,  1.0,
       1.0, -1.0,
       1.0,  1.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    // Set uniforms
    const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
    const centerUniformLocation = gl.getUniformLocation(shaderProgram, 'u_center');
    const zoomUniformLocation = gl.getUniformLocation(shaderProgram, 'u_zoom');

    gl.uniform2f(resolutionUniformLocation, canvas.width / dpr, canvas.height / dpr);

    const center = { x: -0.5, y: 0.0 }; // Adjusted center for better initial view
    let zoom = 0.5; // Adjusted initial zoom

    function render() {
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.uniform2f(centerUniformLocation, center.x, center.y);
      gl.uniform1f(zoomUniformLocation, zoom);

      gl.drawArrays(gl.TRIANGLES, 0, 6);

      zoom *= 1.01; // Slower zoom for smoother animation
      zoomLevelSpan.textContent = `${zoom.toFixed(2)}x`;

      requestAnimationFrame(render);
    }

    // Handle window resize
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = 800 * dpr;
      canvas.height = 800 * dpr;
      canvas.style.width = '800px';
      canvas.style.height = '800px';
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.uniform2f(resolutionUniformLocation, canvas.width / dpr, canvas.height / dpr);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    requestAnimationFrame(render);
  </script>
</body>
</html>